/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package graph;


import java.util.*;

public class App {
    private static final Graph graph2 = new Graph();
    private static final Graph graph = new Graph();
    private static final Graph graph3 = new Graph();

    public static String RomanNumerals(int num) {
        if (num <= 0 || num >= 5000)
            return "invalid number";
        int[] dec = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] rom = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        StringBuilder returnedVal = new StringBuilder();
        for (int i = 0; i < dec.length; i++) {
            while (num >= dec[i]) {
                num -= dec[i];
                returnedVal.append(rom[i]);
            }
        }
        return returnedVal.toString();
    }

    public static String ReverseAString(String exp) {
        Stack<Character> stack = new Stack<>();
        if (exp.length() == 0) return null;
        for (int i = 0; i < exp.length(); i++) {
            stack.push(exp.charAt(i));
        }
        char[] newExp = new char[exp.toCharArray().length];
        for (int i = 0; i < exp.length(); i++) {
            newExp[i] = stack.pop();
        }
        return String.copyValueOf(newExp);
    }


    //    static int largestProduct (int []arr) {
//        if (arr.length < 3)
//            return Integer.MIN_VALUE;
//        int product = 0;
//        for (int i = 0; i < arr.length - 2; i++)
//            for (int j = i + 1; j < arr.length - 1; j++)
//                for (int l = j + 1; l < arr.length; l++)
//                    product = Math.max(product,
//                            arr[i] * arr[j] * arr[l]);
//        return product;
//    }
    public static int largestProduct(int[] arr) {
        if (arr.length < 3)
            return Integer.MIN_VALUE;
        int product1 = 0, product2 = 0, product3 = 0, minProduct1 = 0, minProduct2 = 0;
        for (int i : arr) {
            if (i > product1) {
                product3 = product2;
                product2 = product1;
                product1 = i;
            } else if (i > product2) {
                product3 = product2;
                product2 = i;
            } else if (i > product3) {
                product3 = i;
            }
            if (i < minProduct1) {
                minProduct2 = minProduct1;
                minProduct1 = i;
            } else if (i < minProduct2) {
                minProduct2 = i;
            }
        }
        return Math.max(product1 * product2 * product3, minProduct1 * minProduct2 * product1);
//        return product1 * product2 * product3 > minProduct1 * minProduct2 * product1 ?
//                product1 * product2 * product3 : minProduct1 * minProduct2 * product1;
    }

    public String getGreeting() {
        return "Hello World!";
    }

    static boolean IdentifyAnagrams1(String str1, String str2) {
        char[] str1Array = str1.replaceAll("\\s", "").toLowerCase().toCharArray();
        char[] str2Array = str2.replaceAll("\\s", "").toLowerCase().toCharArray();
        if (str1Array.length != str2Array.length) {
            return false;
        } else {
            Arrays.sort(str1Array);
            Arrays.sort(str2Array);
            return Arrays.equals(str1Array, str2Array);
        }
    }

    /**
     * My way
     *
     * @param str1
     * @param str2
     * @return
     */
    static boolean IdentifyAnagrams(String str1, String str2) {
        char[] str1Array = str1.replaceAll("\\s", "").toLowerCase().toCharArray();
        char[] str2Array = str2.replaceAll("\\s", "").toLowerCase().toCharArray();
        System.out.println(str1Array);
        System.out.println();
        System.out.println(str2Array);

        if (str1Array.length != str2Array.length) {
            return false;
        }
        HashMap<Character, Integer> hashMap1 = new HashMap<>();
        HashMap<Character, Integer> hashMap2 = new HashMap<>();
        for (int i = 0; i < str1.length(); i++) {
            hashMap1.put(str1Array[i], 0);
            hashMap2.put(str2Array[i], 0);
        }
        System.out.println(hashMap1);
        System.out.println();
        System.out.println(hashMap2);

        return hashMap1.equals(hashMap2);
//        In simple words, == checks if both objects point to the same memory location
//        whereas . equals() evaluates to the comparison of values in the objects.
    }

    /**********************************/
//    Given an adjacency matrix representation of a graph, return the adjacency list representation.
    static String adjacencyListRepresentation(int[][] matrix) {
        if (matrix.length == 0)
            return "The matrix is empty";
        List<List<String>> adjacencyList = new ArrayList<>(matrix[0].length);
        char letter;
        //It will create indexes for the vertices
        for (int i : matrix[0]) {
            adjacencyList.add(new ArrayList<>(i));
        }
//        System.out.println(adjacencyList);


        for (int i = 0; i < matrix[0].length; i++) {
            for (int j = 0; j < matrix.length; j++) {
                //if it is edge
                if (matrix[i][j] == 1) {
                    letter = (char) ((int) 'a' + j);
                    adjacencyList.get(i).add(String.valueOf(letter));
                }

            }
        }
//        System.out.println(adjacencyList);

        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < adjacencyList.size(); i++) {
            letter = (char) ((int) 'a' + i);
            stringBuilder.append(letter).append("|");
            for (String edge : adjacencyList.get(i)) {
                stringBuilder.append(" -> ").append(edge);

            }
            stringBuilder.append("\n");
        }
        return stringBuilder.toString();
    }


    public static void main(String[] args) {
        System.out.println(new App().getGreeting());


        graph.addNode("Pandora");
        graph.addNode("Arendelle");
        graph.addNode("Metroville");
        graph.addNode("Monstroplolis");
        graph.addNode("Narnia");
        graph.addNode("Naboo");
//

//        graph.addEdge("Pandora", "Arendelle");
//        graph.addEdge("Arendelle", "Metroville");
//        graph.addEdge("Arendelle", "Monstroplolis");
//        graph.addEdge("Metroville", "Monstroplolis");
//        graph.addEdge("Metroville", "Narnia");
//        graph.addEdge("Metroville", "Naboo");
//        graph.addEdge("Monstroplolis", "Naboo");


//        System.out.println(graph);
//        System.out.println(graph.printGraph());
//        graph.removeVertex("Bob");
//        graph.removeEdge("Alice","Noor");
//        System.out.println( graph.printGraph());
//        System.out.println( graph.size());
//        System.out.println(graph.getNeighbors("Noor"));
//        System.out.println(graph.getNodes());

//        System.out.println(IdentifyAnagrams1("Astronomers", "Moon starers"));
//        System.out.println(IdentifyAnagrams("fried", "fired"));

        /***/
        int[][] list = {{0, 1, 0},
                {1, 0, 1},
                {0, 1, 0}};


        graph2.addNode("Pandora");
        graph2.addNode("Arendelle");
        graph2.addNode("Metroville");
        graph2.addNode("Monstroplolis");
        graph2.addNode("Narnia");
        graph2.addNode("Naboo");

        graph2.addWeightedEdges("Pandora", "Arendelle", 150);
        graph2.addWeightedEdges("Pandora", "Metroville", 82);


        graph2.addWeightedEdges("Arendelle", "Metroville", 99);
        graph2.addWeightedEdges("Arendelle", "Monstroplolis", 42);

        graph2.addWeightedEdges("Metroville", "Monstroplolis", 105);
        graph2.addWeightedEdges("Metroville", "Narnia", 37);
        graph2.addWeightedEdges("Metroville", "Naboo", 26);

        graph2.addWeightedEdges("Monstroplolis", "Naboo", 73);
        graph2.addWeightedEdges("Narnia", "Naboo", 250);

        List<Object> path1 = new ArrayList<>();
        path1.add("Metroville");
        path1.add("Pandora");
        List<Object> path2 = new ArrayList<>();
        path2.add("Arendelle");
        path2.add("Monstroplolis");
        path2.add("Naboo");

        List<Object> path3 = new ArrayList<>();
        path3.add("Naboo");
        path3.add("Pandora");

        List<Object> path4 = new ArrayList<>();
        path4.add("Narnia");
        path4.add("Arendelle");
        path4.add("Naboo");
//        System.out.println(RomanNumerals(5000));
//        System.out.println(RomanNumerals(0));
//        System.out.println(RomanNumerals(2020));
//        System.out.println(RomanNumerals(2099));
//        System.out.println(ReverseAString("hello"));

//        System.out.println(adjacencyListRepresentation(list));
//        System.out.println(graph.breadthFirst("Naboo"));
//        System.out.println(graph.businessTrip(graph2, path1));
//        System.out.println(graph.businessTrip(graph2, path2));
//        System.out.println(graph.businessTrip(graph2, path3));
//        System.out.println(graph.businessTrip(graph2, path4));


//        int[] arr = {18, 3, 42, 17, 9, 27};
//        int n = arr.length;


//        System.out.println("Maximum product is " + largestProduct(arr));
//        System.out.println("Maximum product is " + maxTripletProduct(arr));

        graph3.addNode("A");
        graph3.addNode("B");
        graph3.addNode("C");
        graph3.addNode("G");
        graph3.addNode("D");
        graph3.addNode("E");
        graph3.addNode("H");
        graph3.addNode("F");


        graph3.addEdge("A", "B");
        graph3.addEdge("B", "C");
        graph3.addEdge("C", "G");
        graph3.addEdge("B", "D");
        graph3.addEdge("A", "D");
        graph3.addEdge("D", "E");
        graph3.addEdge("D", "H");
        graph3.addEdge("D", "F");
        graph3.addEdge("H", "F");
        System.out.println(graph3.breadthFirst("A"));
//        System.out.println(graph3.breadthFirst("Aa"));



    }
}
